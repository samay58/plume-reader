# Directory structure:

```
‚îî‚îÄ‚îÄ exa-labs-exa-hallucination-detector/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ components.json
    ‚îú‚îÄ‚îÄ middleware.ts
    ‚îú‚îÄ‚îÄ next.config.mjs
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ postcss.config.js
    ‚îú‚îÄ‚îÄ tailwind.config.ts
    ‚îú‚îÄ‚îÄ tsconfig.json
    ‚îú‚îÄ‚îÄ .env.example
    ‚îú‚îÄ‚îÄ app/
    ‚îÇ   ‚îú‚îÄ‚îÄ globals.css
    ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
    ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
    ‚îÇ   ‚îú‚îÄ‚îÄ api/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exasearch/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ extractclaims/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ verifyclaims/
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ fonts/
    ‚îÇ       ‚îú‚îÄ‚îÄ ABCDiatype-Bold.otf
    ‚îÇ       ‚îú‚îÄ‚îÄ ABCDiatype-Regular.otf
    ‚îÇ       ‚îú‚îÄ‚îÄ GeistMonoVF.woff
    ‚îÇ       ‚îú‚îÄ‚îÄ GeistVF.woff
    ‚îÇ       ‚îú‚îÄ‚îÄ RecklessTRIAL-Medium.woff2
    ‚îÇ       ‚îú‚îÄ‚îÄ RecklessTRIAL-Regular.otf
    ‚îÇ       ‚îî‚îÄ‚îÄ RecklessTRIAL-Regular.woff2
    ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îú‚îÄ‚îÄ ClaimsListResult.tsx
    ‚îÇ   ‚îú‚îÄ‚îÄ FactChecker.tsx
    ‚îÇ   ‚îú‚îÄ‚îÄ PreviewBox.tsx
    ‚îÇ   ‚îú‚îÄ‚îÄ PreviewClaimCard.tsx
    ‚îÇ   ‚îî‚îÄ‚îÄ ui/
    ‚îÇ       ‚îú‚îÄ‚îÄ LoadingMessages.tsx
    ‚îÇ       ‚îú‚îÄ‚îÄ ShareButtons.tsx
    ‚îÇ       ‚îú‚îÄ‚îÄ TagPill.tsx
    ‚îÇ       ‚îú‚îÄ‚îÄ animated-gradient-text.tsx
    ‚îÇ       ‚îî‚îÄ‚îÄ skeleton.tsx
    ‚îú‚îÄ‚îÄ lib/
    ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts
    ‚îî‚îÄ‚îÄ public/


================================================
File: /README.md
================================================

# üîç Hallucinations Detector
### Powered by [Exa.ai](https://exa.ai) - The Search Engine for AIs

![Screenshot](./public/opengraph-image.jpg)

<br>

## üéØ What is Hallucinations Detector?

Hallucinations Detector is a free and open-source tool that helps you verify the accuracy of your content instantly. Think of it as Grammarly, but for factual accuracy instead of grammar. It analyzes your content, identifies potential inaccuracies, and suggests corrections backed by reliable web sources.

<br>

## ‚ú® Key Features

- Real-time fact checking of your LLM generated content
- Source-backed verification
- Detailed explanations for identified inaccuracies
- Suggestion-based corrections

<br>

## üõ†Ô∏è How It Works

1. **Claim Extraction**: When you input your content, the tool uses an LLM (Claude 3.5 Sonnet) to break down your text into individual claims.

2. **Source Verification**: Each claim is checked using Exa‚Äôs search tool to find reliable sources online that either support or refute it.

3. **Accuracy Analysis**: The claims and their corresponding sources are analyzed by our LLM to determine their accuracy.

4. **Results Display**: Finally, we show the results in a simple, clear way, pointing out any mistakes and offering suggestions to fix them.

<br>

## üíª Tech Stack
- **Search Engine**: [Exa.ai](https://exa.ai) - Advanced web search API for AI applications
- **Frontend**: [Next.js](https://nextjs.org/docs) with App Router, [TailwindCSS](https://tailwindcss.com), TypeScript
- **LLM**: [Anthropic's Claude 3.5 Sonnet](https://www.anthropic.com/claude/sonnet) - but you can use any LLM (ex: gpt, gemini, llama or others)
- **AI Integration**: [Vercel AI SDK](https://sdk.vercel.ai/docs/ai-sdk-core)
- **Hosting**: [Vercel](https://vercel.com/) for hosting and analytics

<br>

## üöÄ Getting Started

### Prerequisites
- Node.js
- API keys for Exa.ai and Anthropic

### Installation

1. Clone the repository
```bash
git clone https://github.com/exa-labs/exa-hallucination-detector.git
cd exa-hallucination-detector
````

2.  Install dependencies
    

```
npm install
# or
yarn install
```

3.  Set up environment variables Create a `.env.local` file in the root directory and add your API keys:
    

```
EXA_API_KEY=your_exa_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key
```

4.  Run the development server
    

```
npm run dev
# or
yarn dev
```

5.  Open http://localhost:3000/hallucination-detector in your browser
    
<br>

## üîë API Keys

*   Get your Exa API key from [Exa Dashboard](https://dashboard.exa.ai/api-keys)
    
*   Get your Anthropic API key from [Anthropic Documentation](https://docs.anthropic.com/en/api/getting-started#accessing-the-api)
    
<br>

## ‚≠ê About [Exa.ai](http://Exa.ai)

This project is powered by [Exa.ai](https://exa.ai), a cutting-edge search engine designed specifically for AI applications. Exa provides:

*   Advanced semantic and keyword-based search capabilities
    
*   Instant retrieval of clean web content
    
*   Customizable search parameters
    
*   Similarity search using URLs or text
    
*   Superior search capabilities compared to traditional search APIs
    

[Try Exa search](https://exa.ai/search)

<br>

* * *


Built with ‚ù§Ô∏è by team Exa


================================================
File: /components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================================================
File: /middleware.ts
================================================
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

//redirects https://exa-hallucination-detector.vercel.app to demo.exa.ai/hallucination-detector
export function middleware(request: NextRequest) {
  if (request.headers.get('host') === 'https://exa-hallucination-detector.vercel.app') {
    return NextResponse.redirect('https://demo.exa.ai/hallucination-detector', {
      status: 301
    })
  }
  return NextResponse.next()
}
export const config = {
  matcher: '/:path*'
} 

================================================
File: /next.config.mjs
================================================
/** @type {import('next').NextConfig} */

const nextConfig = {
    basePath: "/hallucination-detector",
    experimental: {
      serverActions: {
        allowedOrigins: ["demo.exa.ai"],
        allowedForwardedHosts: ["demo.exa.ai"],
      },
    },
  };
  
export default nextConfig;

================================================
File: /package.json
================================================
{
  "name": "factchecker",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^0.0.56",
    "@ai-sdk/openai": "^0.0.72",
    "@vercel/analytics": "^1.4.0",
    "ai": "^3.4.33",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "exa-js": "^1.3.2",
    "lucide-react": "^0.456.0",
    "next": "14.1.1",
    "react": "^18",
    "react-dom": "^18",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}


================================================
File: /postcss.config.js
================================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};


================================================
File: /tailwind.config.ts
================================================
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			foreground: 'hsl(var(--foreground))',
  			'background-start': 'rgb(var(--background-start-rgb))',
  			'background-end': 'rgb(var(--background-end-rgb))',
  			'brand-default': 'var(--brand-default)',
  			'brand-fainter': 'var(--brand-fainter)',
  			'brand-faint': 'var(--brand-faint)',
  			'brand-subtle': 'var(--brand-subtle)',
  			'brand-muted': 'var(--brand-muted)',
  			'brand-dark': 'var(--brand-dark)',
  			'brand-darker': 'var(--brand-darker)',
  			'secondary-accent': 'var(--secondary-accent)',
  			'secondary-accent2x': 'var(--secondary-accent2x)',
  			'secondary-dark': 'var(--secondary-dark)',
  			'secondary-darker': 'var(--secondary-darker)',
  			'secondary-darkest': 'var(--secondary-darkest)',
  			'secondary-default': 'var(--secondary-default)',
  			'secondary-faint': 'var(--secondary-faint)',
  			'secondary-fainter': 'var(--secondary-fainter)',
  			'gray-100': 'var(--gray-100)',
  			'gray-200': 'var(--gray-200)',
  			'gray-300': 'var(--gray-300)',
  			'gray-400': 'var(--gray-400)',
  			'gray-50': 'var(--gray-50)',
  			'gray-500': 'var(--gray-500)',
  			'gray-600': 'var(--gray-600)',
  			'gray-700': 'var(--gray-700)',
  			'gray-800': 'var(--gray-800)',
  			'gray-900': 'var(--gray-900)',
  			'gray-950': 'var(--gray-950)',
  			black: 'var(--black)',
  			white: 'var(--white)',
  			'accent-yellow-light': 'var(--accent-yellow-light)',
  			'accent-yellow-dark': 'var(--accent-yellow-dark)',
  			'accent-skyblue-light': 'var(--accent-skyblue-light)',
  			'accent-skyblue-dark': 'var(--accent-skyblue-dark)',
  			'accent-green': 'var(--accent-green)',
  			'accent-red': 'var(--accent-red)',
  			'accent-darkgreen-dark': 'var(--accent-darkgreen-dark)',
  			'accent-darkgreen-light': 'var(--accent-darkgreen-light)',
  			'accent-purple-dark': 'var(--accent-purple-dark)',
  			'accent-purple-light': 'var(--accent-purple-light)',
  			'accent-pink-dark': 'var(--accent-pink-dark)',
  			'accent-pink-light': 'var(--accent-pink-light)',
  			'accent-maroon-dark': 'var(--accent-maroon-dark)',
  			'accent-maroon-light': 'var(--accent-maroon-light)',
  			'dark-accent-skyblue-dark': 'var(--dark-accent-skyblue-dark)',
  			'dark-accent-skyblue-light': 'var(--dark-accent-skyblue-light)',
  			'dark-accent-maroon-dark': 'var(--dark-accent-maroon-dark)',
  			'dark-accent-maroon-light': 'var(--dark-accent-maroon-light)',
  			'dark-accent-green-dark': 'var(--dark-accent-green-dark)',
  			'dark-accent-green-light': 'var(--dark-accent-green-light)',
  			'dark-accent-yellow-dark': 'var(--dark-accent-yellow-dark)',
  			'dark-accent-yellow-light': 'var(--dark-accent-yellow-light)',
  			'dark-accent-purple-dark': 'var(--dark-accent-purple-dark)',
  			'dark-accent-purple-light': 'var(--dark-accent-purple-light)',
  			'dark-accent-pink-dark': 'var(--dark-accent-pink-dark)',
  			'dark-accent-pink-light': 'var(--dark-accent-pink-light)',
  			background: 'hsl(var(--background))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		animation: {
  			'fade-up': 'fade-up 0.5s ease-out forwards'
  		},
  		keyframes: {
  			'fade-up': {
  				'0%': {
  					opacity: '0',
  					transform: 'translateY(20px)'
  				},
  				'100%': {
  					opacity: '1',
  					transform: 'translateY(0)'
  				}
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

================================================
File: /tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


================================================
File: /.env.example
================================================
EXA_API_KEY=your_exa_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key

# This is an example env file. You need to create a file named .env.local in your project folder and add the API key there. If you are deploying this on a hosting platform like Vercel, you should add it to the 'Environment Variables' in the platform's settings.
# Find your Exa API key from here: https://dashboard.exa.ai/api-keys
# Find your Anthropic API key from here: https://docs.anthropic.com/en/api/getting-started#accessing-the-api

================================================
File: /app/globals.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 231, 231, 245;
  --background-end-rgb: 255, 255, 255;

  /* COLORS */
  --brand-default: #254bf1;
  --brand-fainter: #e7ebfd;
  --brand-faint: #c6cfff;
  --brand-subtle: #a1aff7;
  --brand-muted: #4d87e7;
  --brand-dark: #0d2189;
  --brand-darker: #000a40;

  --secondary-accent: #9f9672;
  --secondary-accent2x: #89805d;
  --secondary-dark: #f4f1e7;
  --secondary-darker: #efebdc;
  --secondary-darkest: #e5e0cd;
  --secondary-default: #faf7ec;
  --secondary-faint: #fffdf5;
  --secondary-fainter: #fffefa;

  --gray-50: #fafafa;
  --gray-100: #f5f5f5;
  --gray-200: #e5e5e5;
  --gray-300: #d4d4d4;
  --gray-400: #a3a3a3;
  --gray-500: #737373;
  --gray-600: #525252;
  --gray-700: #404040;
  --gray-800: #262626;
  --gray-900: #171717;
  --gray-950: #0a0a0a;

  --black: #000000;
  --white: #ffffff;

  --accent-yellow-light: #fef3c7;
  --accent-yellow-dark: #92400e;
  --accent-skyblue-light: #dbeafe;
  --accent-skyblue-dark: #1e40af;
  --accent-green: #50b40a;
  --accent-red: #d32f2f;
  --accent-darkgreen-dark: #065f46;
  --accent-darkgreen-light: #d1fae5;
  --accent-purple-dark: #5b21b6;
  --accent-purple-light: #ede9fe;
  --accent-pink-dark: #9d174d;
  --accent-pink-light: #fce7f3;
  --accent-maroon-dark: #991b1b;
  --accent-maroon-light: #fee2e2;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

:root {
  --background: var(--secondary-default);
  --accent: var(--brand-default);
  --accent-background: var(--brand-default);
}

:root {
  --border-default: var(--gray-300);
  --border-radius-default: 2px;

  /* Typography */
  --font-family-sans: 'ABCDiatype', 'Trebuchet MS', sans-serif;
  --font-family-serif: 'Reckless', Georgia, serif;
  --text-light-default: #111827;
  --text-light-muted: #6b7280;
  --text-light-subtle: #9ca3af;
  --text-light-faint: #e5e7eb;
  --text-light-link: #1f40ed;
}

body {
  color: var(--foreground);
  background: var(--background);

  /* Apply ABCDiatype for body */
  font-family: var(--font-abcd-diatype), sans-serif;
}

/* Apply Reckless for headings */
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-reckless), serif;
}


@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}


@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}


@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================================================
File: /app/layout.tsx
================================================
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";
import { Analytics } from '@vercel/analytics/next';

// Load the ABCDiatype font (Regular and Bold only)
const abcdDiatype = localFont({
  src: [
    { path: "./fonts/ABCDiatype-Regular.otf", weight: "400" },
    { path: "./fonts/ABCDiatype-Bold.otf", weight: "700" },
  ],
  variable: "--font-abcd-diatype",
});

// Load the Reckless font (Regular and Medium only)
const reckless = localFont({
  src: [
    { path: "./fonts/RecklessTRIAL-Regular.woff2", weight: "400" },
    { path: "./fonts/RecklessTRIAL-Medium.woff2", weight: "500" },
  ],
  variable: "--font-reckless",
});

export const metadata: Metadata = {
  title: 'Hallucinations Detector Tool',
  description: 'Detect Hallucinations in Your Content Instantly for Free.',
  metadataBase: new URL('https://demo.exa.ai/hallucination-detector'),
  
  // Favicon
  icons: {
    icon: '/favicon1.ico',
    shortcut: '/favicon1.ico',
    apple: '/favicon1.ico',
  },

  // Open Graph
  openGraph: {
    title: 'Hallucinations Detector Tool',
    description: 'Detect Hallucinations in Your Content Instantly for Free.',
    url: 'https://demo.exa.ai/hallucination-detector',
    siteName: 'Hallucinations Detector Tool',
    images: [
      {
        url: '/opengraph-image.jpg',
        width: 1200,
        height: 630,
        alt: 'Hallucinations Detector Tool',
      },
    ],
    locale: 'en_US',
    type: 'website',
  },

  // Twitter
  twitter: {
    card: 'summary_large_image',
    title: 'Hallucinations Detector Tool',
    description: 'Detect Hallucinations in Your Content Instantly for Free.',
    images: ['https://demo.exa.ai/hallucination-detector/opengraph-image.jpg'],
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${abcdDiatype.variable} ${reckless.variable} antialiased`}
      >
        {children}
        <Analytics />
      </body>
    </html>
  );
}

================================================
File: /app/page.tsx
================================================
import FactChecker from '../components/FactChecker';

export default function Home() {
  return (
    <main className="flex relative min-h-screen flex-col items-center justify-center md:p-4">

      {/* background grid design texture code */}
      <div className="absolute inset-0 -z-0 h-full w-full bg-[radial-gradient(#80808060_1px,transparent_1px)] [background-size:30px_30px]"></div>

      <FactChecker />
    </main>
  );
}

================================================
File: /app/api/exasearch/route.ts
================================================
// app/api/exasearch/route.ts
import { NextRequest, NextResponse } from 'next/server';
import Exa from "exa-js";

const exa = new Exa(process.env.EXA_API_KEY as string);

export async function POST(req: NextRequest) {
  try {
    const { claim } = await req.json();
    if (!claim) {
      return NextResponse.json({ error: 'Claim is required' }, { status: 400 });
    }

    // Use Exa to search for content related to the claim
    const result = await exa.searchAndContents(
      `Query: ${claim} \nHere is a web page to help verify this claim:`,
      {
        type: "auto",
        numResults: 3,
        livecrawl: 'always',
        text: true,
      }
    );

    // Extract only url and text from each result
    const simplifiedResults = result.results.map((item: any) => ({
      text: item.text,
      url: item.url
    }));

    return NextResponse.json({ results: simplifiedResults });
  } catch (error) {
    return NextResponse.json({ error: `Failed to perform search | ${error}` }, { status: 500 });
  }
}

================================================
File: /app/api/extractclaims/route.ts
================================================
// app/api/extractclaims/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { anthropic } from "@ai-sdk/anthropic";
import { generateText } from 'ai';

// This function can run for a maximum of 60 seconds
export const maxDuration = 60;

export async function POST(req: NextRequest) {
  try {
    const { content } = await req.json();
    if (!content) {
      return NextResponse.json({ error: 'Content is required' }, { status: 400 });
    }

    // Run the prompt to extract claims along with original text parts
    const { text } = await generateText({
      model: anthropic('claude-3-5-sonnet-20240620'),
      prompt: 
      `You are an expert at extracting claims from text.
      Your task is to identify and list all claims present, true or false, in the given text. Each claim should be a single, verifiable statement.
      If the input content is very lengthy, then pick the major claims.

      For each claim, also provide the original part of the sentence from which the claim is derived.
      Present the claims as a JSON array of objects. Each object should have two keys:
      - "claim": the extracted claim in a single verifiable statement.
      - "original_text": the portion of the original text that supports or contains the claim.
      
      Do not include any additional text or commentary.

      Here is the content: ${content}

      Return the output strictly as a JSON array of objects following this schema:
      [
        {
          "claim": "extracted claim here",
          "original_text": "original text portion here"
        },
        ...
      ]

        Output the result as valid JSON, strictly adhering to the defined schema. Ensure there are no markdown codes or additional elements included in the output. Do not add anything else. Return only JSON.
      `,
    });

    return NextResponse.json({ claims: JSON.parse(text) });
  } catch (error) {
    return NextResponse.json({ error: `Failed to extract claims | ${error}` }, { status: 500 });
  }
}


================================================
File: /app/api/verifyclaims/route.ts
================================================
// app/api/verifyclaims/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { anthropic } from "@ai-sdk/anthropic";
import { generateObject } from 'ai';
import { z } from 'zod';

export const maxDuration = 60;

export async function POST(req: NextRequest) {
  try {
    const { claim, original_text, exasources } = await req.json();

    if (!claim || !original_text || !exasources) {
      return NextResponse.json({ error: 'Claim and sources are required' }, { status: 400 });
    }

    const factCheckSchema = z.object({
      claim: z.string(),
      assessment: z.enum(["True", "False", "Insufficient Information"]),
      summary: z.string(),
      fixed_original_text: z.string(),
      confidence_score: z.number().min(0).max(100)
    });

    const { object } = await generateObject({
      model: anthropic('claude-3-5-sonnet-20240620'),
      schema: factCheckSchema,
      output: 'object',
      prompt: `You are an expert fact-checker. Given a claim and a set of sources, determine whether the claim is true or false based on the text from sources (or if there is insufficient information).
    
      For your analysis, consider all the sources collectively.

      Here are the sources: ${exasources}

      Here is the Original part of the text: ${original_text}

      Here is the claim: ${claim}

      Provide your answer as a JSON object with the following structure:

      claim: "...",
      assessment: "True" or "False" or "Insufficient Information",
      summary: "Why is this claim correct and if it isn't correct, then what's correct. In a single line.",
      fixed_original_text: "If the assessment is False then correct the original text (keeping everything as it is and just fix the fact in the part of the text)",
      confidence_score: a percentage number between 0 and 100 (100 means fully confident that the decision you have made is correct, 0 means you are completely unsure),
      
      `
    });

    console.log('LLM response:', object);
    
    return NextResponse.json({ claims: object });
  } catch (error) {
    console.error('Verify claims API error:', error);
    return NextResponse.json({ error: `Failed to extract claims | ${error}` }, { status: 500 });
  }
}

================================================
File: /components/ClaimsListResult.tsx
================================================
import React from 'react';
import { ChevronRight } from 'lucide-react';

interface ClaimsListResult {
  claim: string;
  assessment: string;
  summary: string;
  fixed_original_text: string;
  confidence_score: number;
  url_sources?: string[];
}

interface ClaimsListResultsProps {
  results: ClaimsListResult[];
}

const ClaimsListResults: React.FC<ClaimsListResultsProps> = ({ results }) => {
  const getStatusBadge = (assessment: string) => {
    const isTrue = assessment.toLowerCase().includes('true');
    return (
      <span 
        className={`inline-flex items-center px-3 py-1 rounded-none text-sm font-medium ${
          isTrue 
            ? 'bg-green-100 text-green-800 border border-green-200' 
            : 'bg-red-100 text-red-800 border border-red-200'
        }`}
      >
        <span className="mr-2">{isTrue ? '‚úÖ' : '‚ùå'}</span>
        {isTrue ? 'Supported' : 'Refuted'}
      </span>
    );
  };

  return (
    <div className="mt-6 w-full bg-white p-6 border rounded-none shadow-sm space-y-16">
      {results
      .filter((result) => result.assessment.toLowerCase() !== 'insufficient information')
      .map((result, index) => (
        <div key={index} className="space-y-4">
          <h3 className="font-semibold text-lg text-gray-900">{result.claim}</h3>
          
          <div className="flex items-center space-x-3">
            {getStatusBadge(result.assessment)}
            <span className="text-gray-600 text-sm">
              {result.confidence_score}% Confident
            </span>
          </div>
          
          <p className="text-gray-700 mt-2">{result.summary}</p>

          {/* <p className="text-gray-700 mt-2">{result.fixed_original_text}</p> */}
          
          <div className="mt-4">
            <div className="flex items-center space-x-2 text-gray-700 mb-2">
              <ChevronRight size={20} />
              <span className="font-medium">Sources</span>
            </div>
            
            <ul className="space-y-2 pl-6">
              {result.url_sources && result.url_sources.length > 0 ? (
                result.url_sources.map((source, idx) => (
                  <li key={idx}>
                    <a 
                      href={source}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-blue-600 hover:text-blue-800 hover:underline text-sm break-all"
                    >
                      {source}
                    </a>
                  </li>
                ))
              ) : (
                <li className="text-gray-500 italic">No sources available</li>
              )}
            </ul>
          </div>
        </div>
      ))}
    </div>
  );
};

export default ClaimsListResults;

================================================
File: /components/FactChecker.tsx
================================================
"use client";

import Link from "next/link";
import { useState, FormEvent, useRef, useEffect } from "react";
import ClaimsListResults from "./ClaimsListResult";
import LoadingMessages from "./ui/LoadingMessages";
import PreviewBox from "./PreviewBox";
import { ChevronDown, ChevronRight, ChevronUp } from "lucide-react";
import AnimatedGradientText from "./ui/animated-gradient-text";
import ShareButtons from "./ui/ShareButtons";
import { getAssetPath } from "@/lib/utils";

interface Claim {
    claim: string;
    original_text: string;
}

type FactCheckResponse = {
  claim: string;
  assessment: "True" | "False" | "Insufficient Information";
  summary: string;
  fixed_original_text: string;
  confidence_score: number;
};

export default function FactChecker() {
  const [isGenerating, setIsGenerating] = useState(false);
  const [factCheckResults, setFactCheckResults] = useState<any[]>([]);
  const [articleContent, setArticleContent] = useState('');
  const [error, setError] = useState<string | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [showAllClaims, setShowAllClaims] = useState(true);

  // Create a ref for the loading or bottom section
  const loadingRef = useRef<HTMLDivElement>(null);

  // Function to scroll to the loading section
  const scrollToLoading = () => {
    loadingRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  // Watch for changes to `isGenerating` and scroll when it becomes `true`
  useEffect(() => {
    if (isGenerating) {
      scrollToLoading();
    }
  }, [isGenerating]);

  // Function to adjust textarea height
  const adjustTextareaHeight = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = '150px';
      const scrollHeight = textarea.scrollHeight;
      textarea.style.height = `${Math.min(scrollHeight, 300)}px`;
    }
  };

  // Adjust height when content changes
  useEffect(() => {
    adjustTextareaHeight();
  }, [articleContent]);

  // Extract claims function
  const extractClaims = async (content: string) => {
    const response = await fetch(getAssetPath('/api/extractclaims'), {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ content }),
    });
  
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to extract claims.');
    }
  
    const data = await response.json();
    return Array.isArray(data.claims) ? data.claims : JSON.parse(data.claims);
  };
  
  // ExaSearch function
  const exaSearch = async (claim: string) => {
    console.log(`Claim recieved in exa search: ${claim}`);

    const response = await fetch(getAssetPath('/api/exasearch'), {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ claim }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to fetch verification for claim.');
    }

    const data = await response.json();
    return data;
  };

  // Verify claims function
  const verifyClaim = async (claim: string, original_text: string, exasources: any) => {
    const response = await fetch(getAssetPath('/api/verifyclaims'), {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ claim, original_text, exasources }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to verify claim.');
    }

    const data = await response.json();
    console.log("VerifyClaim response:", data.claims);

    return data.claims as FactCheckResponse;
  };
   
  // Fact check function
  const factCheck = async (e: FormEvent) => {
    e.preventDefault();
  
    if (!articleContent) {
      setError("Please enter some content or try with sample blog.");
      return;
    }

    if (articleContent.length < 50) {
      setError("Too short. Please enter at least 50 characters.");
      return;
    }
  
    setIsGenerating(true);
    setError(null);
    setFactCheckResults([]);
  
    try {
      const claims = await extractClaims(articleContent);
      const finalResults = await Promise.all(
        claims.map(async ({ claim, original_text }: Claim) => {
          try {
            const exaSources = await exaSearch(claim);
            
            if (!exaSources?.results?.length) {
              return null;
            }
    
            const sourceUrls = exaSources.results.map((result: { url: any; }) => result.url);
            
            const verifiedClaim = await verifyClaim(claim, original_text, exaSources.results);
    
            return { ...verifiedClaim, original_text, url_sources: sourceUrls };
          } catch (error) {
            console.error(`Failed to verify claim: ${claim}`, error);
            return null;
          }
        })
      );
  
      setFactCheckResults(finalResults.filter(result => result !== null));
    } catch (error) {
      setError(error instanceof Error ? error.message : 'An unexpected error occurred.');
      setFactCheckResults([]);
    } finally {
      setIsGenerating(false);
    }
  };

  // Sample blog content
  const sampleBlog = `The Eiffel Tower, a remarkable iron lattice structure standing proudly in Paris, was originally built as a giant sundial in 1822, intended to cast shadows across the city to mark the hours. Designed by the renowned architect Gustave Eiffel, the tower stands 324 meters tall and once housed the city's first observatory.\n\nWhile it's famously known for hosting over 7 million visitors annually, it was initially disliked by Parisians. Interestingly, the Eiffel Tower was used as to guide ships along the Seine during cloudy nights.`;

  // Load sample content function
  const loadSampleContent = () => {
    setArticleContent(sampleBlog);
    setError(null);
  };

  return (
    <div className="flex flex-col min-h-screen z-0">

        {/* Badge positioned at the top */}
      <div className="w-full flex justify-center pt-10 opacity-0 animate-fade-up [animation-delay:200ms]">
        <Link href="https://exa.ai/" target="_blank">
          <AnimatedGradientText>
          <img 
            src={getAssetPath('/exaicon.png')} 
            alt="exa logo" 
            className="w-5 h-5 inline-block mr-2" 
          />
            <span className="inline animate-gradient bg-gradient-to-r from-[#254bf1] via-purple-600 to-[#254bf1] bg-[length:var(--bg-size)_100%] bg-clip-text text-transparent">
              Built on Exa - Search Engine for AI
            </span>
            <ChevronRight className="ml-1 size-3 transition-transform duration-300 ease-in-out group-hover:translate-x-0.5" />
          </AnimatedGradientText>
        </Link>
      </div>

      <main className="flex flex-col items-center justify-center flex-grow w-full max-w-6xl md:max-w-4xl p-6">
        <div className="text-left">
          <h1 className="md:text-6xl text-4xl pb-5 font-medium opacity-0 animate-fade-up [animation-delay:400ms]">
            Detect LLM 
            <span className="text-brand-default"> Hallucinations </span>
          </h1>

          <p className="text-gray-800 mb-12 opacity-0 animate-fade-up [animation-delay:600ms]">
            Verify your content with real web data.
          </p>
        </div>
    
        <form onSubmit={factCheck} className="space-y-6 w-full mb-10">
          <textarea
            ref={textareaRef}
            value={articleContent}
            onChange={(e) => setArticleContent(e.target.value)}
            placeholder="Enter Your Content"
            className="w-full bg-white p-3 border box-border outline-none rounded-none ring-2 ring-brand-default resize-none min-h-[150px] max-h-[250px] overflow-auto opacity-0 animate-fade-up [animation-delay:800ms] transition-[height] duration-200 ease-in-out"
          />

          <div className="pb-5">
            <button
              onClick={loadSampleContent}
              disabled={isGenerating}
              className={`px-3 py-2 border-2 border-brand-default text-brand-default font-semibold rounded-none hover:bg-brand-default hover:text-white transition-all opacity-0 animate-fade-up [animation-delay:1000ms] ${
                isGenerating ? 'cursor-not-allowed' : ''
              }`}
            >
              Try with a sample blog post
            </button>
          </div>

          <button
            type="submit"
            className={`w-full text-white mb-10 font-semibold px-2 py-2 rounded-none transition-opacity opacity-0 animate-fade-up [animation-delay:1200ms] min-h-[50px] ${
              isGenerating ? 'bg-gray-400' : 'bg-brand-default ring-2 ring-brand-default'
            } transition-colors`}
            disabled={isGenerating}
          >
            {isGenerating ? 'Detecting Hallucinations...' : 'Detect Hallucinations'}
          </button>
        </form>

        {isGenerating && (
            <div ref={loadingRef} className="w-full">
            <LoadingMessages isGenerating={isGenerating} />
            </div>
        )}

        {error && (
          <div className="mt-1 mb-14 p-3 bg-red-100 border border-red-400 animate-fade-up text-red-700 rounded-none">
            {error}
          </div>
        )}


       

        {factCheckResults.length > 0 && (
        <div className="space-y-14 mt-5 mb-32">
            <PreviewBox
            content={articleContent}
            claims={factCheckResults}
            />
            <div className="mt-4 pt-12 opacity-0 animate-fade-up [animation-delay:800ms]">
                <button
                onClick={() => setShowAllClaims(!showAllClaims)}
                className="flex items-center space-x-2 text-gray-700 hover:text-gray-900 font-medium"
                >
                {showAllClaims ? (
                    <>
                    <span>Hide Claims</span>
                    <ChevronUp size={20} />
                    </>
                ) : (
                    <>
                    <span>Show All Claims</span>
                    <ChevronDown size={20} />
                    </>
                )}
                </button>

                {/* Claims List */}
                {showAllClaims && (
                <div>
                    <ClaimsListResults results={factCheckResults} />
                </div>
                )}
            </div>
            <ShareButtons />
        </div>
        )}


      </main>
  
      <footer className="w-full py-6 px-8 mb-6 mt-auto opacity-0 animate-fade-up [animation-delay:1400ms]">
        <div className="max-w-md mx-auto">
          <p className="text-md text-center text-gray-600">
            <Link 
              href="https://github.com/exa-labs/exa-hallucination-detector" 
              target="_blank"
              className="underline cursor-pointer"
            >
              This is an open source project - clone it here
            </Link>
          </p>
        </div>
      </footer>
    </div>
  );
}

================================================
File: /components/PreviewBox.tsx
================================================
// PreviewBox.tsx
import React, { useState, useEffect } from 'react';
import { PreviewClaimCard } from './PreviewClaimCard';
import { Copy, CheckCheck } from 'lucide-react';

interface Claim {
  claim: string;
  assessment: string;
  summary: string;
  original_text: string;
  fixed_original_text: string;
  confidence_score: number;
  url_sources?: string[];
}

interface PreviewBoxProps {
  content: string;
  claims: Claim[];
}

const PreviewBox: React.FC<PreviewBoxProps> = ({ content, claims }) => {
  const [displayText, setDisplayText] = useState(content);
  const [selectedClaim, setSelectedClaim] = useState<Claim | null>(null);
  const [copied, setCopied] = useState(false);

  // Filter out claims with "Insufficient Information"
  const filteredClaims = claims.filter(
    (claim) => claim.assessment.toLowerCase() !== 'insufficient information'
  );

  const claimsNeedingFix = filteredClaims.filter(
    (claim) => claim.assessment.toLowerCase() === 'false'
  );

  useEffect(() => {
    if (claimsNeedingFix.length > 0 && !selectedClaim) {
      setSelectedClaim(claimsNeedingFix[0]);
    }
  }, [claimsNeedingFix]);

  const highlightClaims = () => {
    let segments = [];
    let lastIndex = 0;

    const sortedClaims = [...filteredClaims].sort((a, b) => {
      return displayText.indexOf(a.original_text) - displayText.indexOf(b.original_text);
    });

    sortedClaims.forEach((claim) => {
      const index = displayText.indexOf(claim.original_text, lastIndex);
      if (index !== -1) {
        const previousText = displayText.substring(lastIndex, index);
        segments.push(
          previousText.split('\n').map((line, i) => (
            <React.Fragment key={`text-${lastIndex}-${i}`}>
              {i > 0 && <br />}
              {line}
            </React.Fragment>
          ))
        );

        const isTrue = claim.assessment.toLowerCase().includes('true');
        segments.push(
          <span
            key={`claim-${index}`}
            className={`cursor-pointer border-b-2 ${
              isTrue ? 'border-green-500 hover:bg-green-100' : 'border-red-500 hover:bg-red-100'
            } ${selectedClaim === claim ? isTrue ? 'bg-green-100' : 'bg-red-100' : ''}`}
            onClick={() => setSelectedClaim(claim)}
          >
            {claim.original_text}
          </span>
        );
        lastIndex = index + claim.original_text.length;
      }
    });

    const remainingText = displayText.substring(lastIndex);
    segments.push(
      remainingText.split('\n').map((line, i) => (
        <React.Fragment key={`text-end-${i}`}>
          {i > 0 && <br />}
          {line}
        </React.Fragment>
      ))
    );

    return segments;
  };

  const acceptFix = (claim: Claim) => {
    setDisplayText(displayText.replace(claim.original_text, claim.fixed_original_text));
    
    const currentIndex = claimsNeedingFix.indexOf(claim);
    const nextClaim = claimsNeedingFix[currentIndex + 1];
    setSelectedClaim(nextClaim || null);
  };

  const handleCopy = async () => {
    await navigator.clipboard.writeText(displayText);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="space-y-8 w-full">

      {/* Preview Box */}
      <div className="relative">
        <div className="w-full min-h-[200px] p-6 bg-white border rounded-none shadow-sm opacity-0 animate-fade-up [animation-delay:200ms]">
          {highlightClaims()}
        </div>
        
        {/* Copy Button */}
        <div className="flex justify-end mt-3 mb-10 mr-5 opacity-0 animate-fade-up [animation-delay:400ms]">
          <button
            onClick={handleCopy}
            className="flex items-center space-x-2 text-sm text-gray-600 hover:text-gray-900"
          >
            {copied ? (
              <>
                <CheckCheck size={16} />
                <span>Copied!</span>
              </>
            ) : (
              <>
                <Copy size={16} />
                <span>Copy all text</span>
              </>
            )}
          </button>
        </div>
      </div>

      {selectedClaim && (
        <PreviewClaimCard
          claim={selectedClaim}
          onAcceptFix={acceptFix}
        />
      )}
    </div>
  );
};

export default PreviewBox;

================================================
File: /components/PreviewClaimCard.tsx
================================================
// PreviewClaimCard.tsx
import React from 'react';
import { ChevronRight } from 'lucide-react';

interface Claim {
  claim: string;
  assessment: string;
  summary: string;
  original_text: string;
  fixed_original_text: string;
  confidence_score: number;
  url_sources?: string[];
}

interface PreviewClaimCardProps {
  claim: Claim;
  onAcceptFix: (claim: Claim) => void;
}

export const PreviewClaimCard: React.FC<PreviewClaimCardProps> = ({ claim, onAcceptFix }) => {
  const isTrue = claim.assessment.toLowerCase().includes('true');
  const hasFix = claim.fixed_original_text !== claim.original_text;

  return (
    <div className="bg-white border rounded-none shadow-sm p-6 space-y-4 opacity-0 animate-fade-up [animation-delay:600ms]">
      <h3 className="font-semibold text-lg text-gray-900">{claim.claim}</h3>

      <div className="flex items-center gap-3">
        <span
          className={`inline-flex items-center px-3 py-1 rounded-none text-sm font-medium ${
            isTrue
              ? 'bg-green-100 text-green-800 border border-green-200'
              : 'bg-red-100 text-red-800 border border-red-200'
          }`}
        >
          <span className="mr-2">{isTrue ? '‚úÖ' : '‚ùå'}</span>
          {isTrue ? 'Supported' : 'Refuted'}
        </span>
        <span className="text-gray-600 text-sm">
          {claim.confidence_score}% Confident
        </span>
      </div>

      <p className="text-gray-700">{claim.summary}</p>

      <div className="space-y-2 pt-1">
        <div className="flex items-center gap-2 text-gray-700">
          <ChevronRight size={20} />
          <span className="font-medium">Sources</span>
        </div>
        
        <ul className="space-y-2 pl-6">
          {claim.url_sources && claim.url_sources.length > 0 ? (
            claim.url_sources.map((source, idx) => (
              <li key={idx}>
                <a
                  href={source}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-600 hover:text-blue-800 hover:underline text-sm break-all"
                >
                  {source}
                </a>
              </li>
            ))
          ) : (
            <li className="text-gray-500 italic">No sources available</li>
          )}
        </ul>
      </div>

      {hasFix && (
        <div className="pt-5 space-y-2">
            <div className="flex items-center gap-2">
                <span className="font-medium text-gray-700">Suggested Fix</span>
            </div>
                <div className="space-y-2 pb-2">
                    <p className="text-gray-500 line-through">{claim.original_text}</p>
                    <p className="text-green-700">{claim.fixed_original_text}</p>
                </div>
                <button
                    onClick={() => onAcceptFix(claim)}
                    className="w-full mt-4 px-4 py-2 bg-brand-default text-white font-semibold rounded-none hover:ring-1 transition-colors"
                    >
                    Accept Fix
                </button>
        </div>
        )}

    </div>
  );
};

================================================
File: /components/ui/LoadingMessages.tsx
================================================
import { useEffect, useState } from "react";
import { Skeleton } from "./skeleton";

type LoadingMessagesProps = {
  isGenerating: boolean;
};

const loadingMessages = [
  "üîç\u00A0\u00A0Analyzing Your Content...",
  "üìù\u00A0\u00A0Extracting Key Claims...",
  "üìö\u00A0\u00A0Searching for Reliable Sources...",
  "üîç\u00A0\u00A0Verifying Each Claim for Accuracy...",
  "üìä\u00A0\u00A0Generating Your Results...",
  "Almost there...\u00A0\u00A0üéâ",
];

const LoadingMessages: React.FC<LoadingMessagesProps> = ({ isGenerating }) => {
  const [currentMessageIndex, setCurrentMessageIndex] = useState(0);

  useEffect(() => {
    let intervalId: NodeJS.Timeout;

    if (isGenerating) {
      setCurrentMessageIndex(0);

      // Set interval to change the message every 1-3 seconds
      intervalId = setInterval(() => {
        setCurrentMessageIndex((prevIndex) => {
          const nextIndex = prevIndex + 1;

          if (nextIndex < loadingMessages.length) {
            return nextIndex;
          } else {
            clearInterval(intervalId);
            return prevIndex;
          }
        });
      }, Math.floor(Math.random() * 9000) + 3000);
    } else {
      setCurrentMessageIndex(0);
    }

    return () => clearInterval(intervalId);
  }, [isGenerating]);

  return (
    <div className="w-full mt-20 mb-40">
      <div className="text-secondary-accent/50 text-lg opacity-0 animate-fade-up [animation-delay:200ms]">
        {isGenerating ? loadingMessages[currentMessageIndex] : ""}
      </div>

      <div className="flex flex-col space-y-3 mt-6">
        <Skeleton className="h-[100px] rounded-none bg-secondary-accent opacity-0 animate-fade-up [animation-delay:400ms]" />
        <div className="space-y-2">
          <Skeleton className="h-4 rounded-none bg-secondary-accent opacity-0 animate-fade-up [animation-delay:500ms]" />
          <Skeleton className="h-4 rounded-none bg-secondary-accent opacity-0 animate-fade-up [animation-delay:600ms]" />
        </div>
      </div>
    </div>
  );
};

export default LoadingMessages;

================================================
File: /components/ui/ShareButtons.tsx
================================================
"use client";
import { useState } from 'react';
import { Twitter, Linkedin, Users } from 'lucide-react';

export default function ShareButtons() {
    const [copyMessage, setCopyMessage] = useState('');
    const toolUrl = 'https://demo.exa.ai/hallucination-detector';
    const shareText = `Just saw this AI tool which can detect hallucinations in your content, seems cool \n\n${toolUrl}`;

    const shareOnTwitter = () => {
        const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}`;
        window.open(twitterUrl, '_blank');
    };

    const shareOnLinkedIn = () => {
        const linkedinUrl = `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(toolUrl)}`;
        window.open(linkedinUrl, '_blank');
    };

    const copyToClipboard = async () => {
        try {
            await navigator.clipboard.writeText(toolUrl);
            setCopyMessage('Copied! Now share the link with your team üöÄ');
            setTimeout(() => setCopyMessage(''), 3000);
        } catch (err) {
            setCopyMessage('Failed to copy');
        }
    };

    return (
        <div className="my-12 pt-12 space-y-6 opacity-0 animate-fade-up">
            <h3 className="text-lg text-center text-black mb-6">
                Share this hallucinations detector tool now!
            </h3>
            <div className="flex flex-col sm:flex-row justify-center gap-8">
                <button
                    onClick={shareOnTwitter}
                    className="flex items-center justify-center gap-2 px-6 py-3 bg-[#1DA1F2] text-white rounded-none hover:bg-[#1a8cd8] transition-colors duration-200"
                >
                    <Twitter size={20} />
                    <span>Share on Twitter</span>
                </button>

                <button
                    onClick={shareOnLinkedIn}
                    className="flex items-center justify-center gap-2 px-6 py-3 bg-[#0A66C2] text-white rounded-none hover:bg-[#094d92] transition-colors duration-200"
                >
                    <Linkedin size={20} />
                    <span>Share on LinkedIn</span>
                </button>

                <button
                    onClick={copyToClipboard}
                    className="flex items-center justify-center gap-2 px-6 py-3 bg-gray-800 text-white rounded-none hover:bg-gray-700 transition-colors duration-200"
                >
                    <Users size={20} />
                    <span>Share with Your Team</span>
                </button>
            </div>
            {copyMessage && (
                <div className="text-center text-green-600 font-medium mt-4 animate-fade-up">
                    {copyMessage}
                </div>
            )}
        </div>
    );
}

================================================
File: /components/ui/TagPill.tsx
================================================
import React from 'react';

interface TagPillProps {
  content: string;
  icon?: React.ReactNode;
}

const TagPill = ({ content, icon }: TagPillProps) => {
  return (
    <div className="inline-flex items-center px-3 py-2 rounded-full bg-brand-fainter text-brand-default text-sm break-all">
      <div className="flex items-center min-w-0">
        {icon && <span className="mr-2 flex-shrink-0">{icon}</span>}
        <span className="truncate">{content}</span>
      </div>
    </div>
  );
};

export default TagPill;

================================================
File: /components/ui/animated-gradient-text.tsx
================================================
import { ReactNode } from "react";

import { cn } from "../../lib/utils";

export default function AnimatedGradientText({
  children,
  className,
}: {
  children: ReactNode;
  className?: string;
}) {
  return (
    <div
      className={cn(
        "group relative mx-auto flex max-w-fit flex-row items-center justify-center rounded-2xl bg-white/40 px-4 py-1.5 text-sm font-medium shadow-[inset_0_-8px_10px_#8fdfff1f] backdrop-blur-sm transition-shadow duration-500 ease-out [--bg-size:300%] hover:shadow-[inset_0_-5px_10px_#8fdfff3f] dark:bg-black/40",
        className,
      )}
    >
      <div
        className={`absolute inset-0 block h-full w-full animate-gradient bg-gradient-to-r from-[#254bf1]/50 via-purple-600/50 to-[#254bf1]/50 bg-[length:var(--bg-size)_100%] p-[1px] ![mask-composite:subtract] [border-radius:inherit] [mask:linear-gradient(#fff_0_0)_content-box,linear-gradient(#fff_0_0)]`}
      />

      {children}
    </div>
  );
}

================================================
File: /components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }


================================================
File: /lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export const getAssetPath = (path: string): string => {
  return `/hallucination-detector${path}`;
};

